<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RTAI API: Message handling functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTAI API
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__msg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message handling functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:msg_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html">msg.c</a></td></tr>
<tr class="memdesc:msg_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message handling functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66551d6fbb13667461bc3bf2cf83e107"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga66551d6fbb13667461bc3bf2cf83e107">rt_send</a> (RT_TASK *task, unsigned long msg)</td></tr>
<tr class="memdesc:ga66551d6fbb13667461bc3bf2cf83e107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message.  <a href="#ga66551d6fbb13667461bc3bf2cf83e107">More...</a><br /></td></tr>
<tr class="separator:ga66551d6fbb13667461bc3bf2cf83e107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70eb31e5f122413970a84758dceb4f90"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga70eb31e5f122413970a84758dceb4f90">rt_send_if</a> (RT_TASK *task, unsigned long msg)</td></tr>
<tr class="memdesc:ga70eb31e5f122413970a84758dceb4f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message, only if the calling task will not be blocked.  <a href="#ga70eb31e5f122413970a84758dceb4f90">More...</a><br /></td></tr>
<tr class="separator:ga70eb31e5f122413970a84758dceb4f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27326d8228e55c84003b12585bc10ada"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga27326d8228e55c84003b12585bc10ada">rt_send_until</a> (RT_TASK *task, unsigned long msg, RTIME time)</td></tr>
<tr class="separator:ga27326d8228e55c84003b12585bc10ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d44740570af52c6a94485e38f6dc9fd"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga5d44740570af52c6a94485e38f6dc9fd">rt_send_timed</a> (RT_TASK *task, unsigned long msg, RTIME delay)</td></tr>
<tr class="separator:ga5d44740570af52c6a94485e38f6dc9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae46a3a1a13048f75a77ce6dc0c3694"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga7ae46a3a1a13048f75a77ce6dc0c3694">rt_evdrp</a> (RT_TASK *task, void *msg)</td></tr>
<tr class="memdesc:ga7ae46a3a1a13048f75a77ce6dc0c3694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eavedrop (spy) the content of a message.  <a href="#ga7ae46a3a1a13048f75a77ce6dc0c3694">More...</a><br /></td></tr>
<tr class="separator:ga7ae46a3a1a13048f75a77ce6dc0c3694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2e8aa05f0f3b11c3e28924bf63e530"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#gafb2e8aa05f0f3b11c3e28924bf63e530">rt_receive</a> (RT_TASK *task, void *msg)</td></tr>
<tr class="memdesc:gafb2e8aa05f0f3b11c3e28924bf63e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message.  <a href="#gafb2e8aa05f0f3b11c3e28924bf63e530">More...</a><br /></td></tr>
<tr class="separator:gafb2e8aa05f0f3b11c3e28924bf63e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2733ad5fb78c18383f08603f57e65b5e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga2733ad5fb78c18383f08603f57e65b5e">rt_receive_if</a> (RT_TASK *task, void *msg)</td></tr>
<tr class="memdesc:ga2733ad5fb78c18383f08603f57e65b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message, only if the calling task is not blocked.  <a href="#ga2733ad5fb78c18383f08603f57e65b5e">More...</a><br /></td></tr>
<tr class="separator:ga2733ad5fb78c18383f08603f57e65b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152b1feae638de4c1de0beb37f5ff2ca"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga152b1feae638de4c1de0beb37f5ff2ca">rt_receive_until</a> (RT_TASK *task, void *msg, RTIME time)</td></tr>
<tr class="memdesc:ga152b1feae638de4c1de0beb37f5ff2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message with an absolute timeout.  <a href="#ga152b1feae638de4c1de0beb37f5ff2ca">More...</a><br /></td></tr>
<tr class="separator:ga152b1feae638de4c1de0beb37f5ff2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffc119c4207193b778ecdfbe62b691d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#gacffc119c4207193b778ecdfbe62b691d">rt_receive_timed</a> (RT_TASK *task, void *msg, RTIME delay)</td></tr>
<tr class="memdesc:gacffc119c4207193b778ecdfbe62b691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message with a relative timeout.  <a href="#gacffc119c4207193b778ecdfbe62b691d">More...</a><br /></td></tr>
<tr class="separator:gacffc119c4207193b778ecdfbe62b691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b06c847361f918a41815d46786a54c4"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga3b06c847361f918a41815d46786a54c4">rt_sendx</a> (RT_TASK *task, void *msg, int size)</td></tr>
<tr class="memdesc:ga3b06c847361f918a41815d46786a54c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an extended message.  <a href="#ga3b06c847361f918a41815d46786a54c4">More...</a><br /></td></tr>
<tr class="separator:ga3b06c847361f918a41815d46786a54c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d2092690b522efd2a855beded37b7c"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#gaf7d2092690b522efd2a855beded37b7c">rt_sendx_if</a> (RT_TASK *task, void *msg, int size)</td></tr>
<tr class="memdesc:gaf7d2092690b522efd2a855beded37b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an extended message, only if the calling task will not be blocked.  <a href="#gaf7d2092690b522efd2a855beded37b7c">More...</a><br /></td></tr>
<tr class="separator:gaf7d2092690b522efd2a855beded37b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc1485992f6ae3911b84d4a95403fee"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga7dc1485992f6ae3911b84d4a95403fee">rt_sendx_until</a> (RT_TASK *task, void *msg, int size, RTIME time)</td></tr>
<tr class="memdesc:ga7dc1485992f6ae3911b84d4a95403fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an extended message with absolute timeout.  <a href="#ga7dc1485992f6ae3911b84d4a95403fee">More...</a><br /></td></tr>
<tr class="separator:ga7dc1485992f6ae3911b84d4a95403fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b688e75d34a3b39aca5abdb61e4c900"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga9b688e75d34a3b39aca5abdb61e4c900">rt_sendx_timed</a> (RT_TASK *task, void *msg, int size, RTIME delay)</td></tr>
<tr class="memdesc:ga9b688e75d34a3b39aca5abdb61e4c900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an extended message with relative timeout.  <a href="#ga9b688e75d34a3b39aca5abdb61e4c900">More...</a><br /></td></tr>
<tr class="separator:ga9b688e75d34a3b39aca5abdb61e4c900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81288491d5c7da929767622eba807ae7"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga81288491d5c7da929767622eba807ae7">rt_evdrpx</a> (RT_TASK *task, void *msg, int size, long *len)</td></tr>
<tr class="memdesc:ga81288491d5c7da929767622eba807ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eavedrop (spy) the content of an extended message.  <a href="#ga81288491d5c7da929767622eba807ae7">More...</a><br /></td></tr>
<tr class="separator:ga81288491d5c7da929767622eba807ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b744298e1d4565b14f8572490820b14"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga3b744298e1d4565b14f8572490820b14">rt_receivex</a> (RT_TASK *task, void *msg, int size, long *len)</td></tr>
<tr class="memdesc:ga3b744298e1d4565b14f8572490820b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an extended message.  <a href="#ga3b744298e1d4565b14f8572490820b14">More...</a><br /></td></tr>
<tr class="separator:ga3b744298e1d4565b14f8572490820b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c582f9a04b1d3332295d9d2ea7bf5b6"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga1c582f9a04b1d3332295d9d2ea7bf5b6">rt_receivex_if</a> (RT_TASK *task, void *msg, int size, long *len)</td></tr>
<tr class="memdesc:ga1c582f9a04b1d3332295d9d2ea7bf5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an extended message, only if the calling task is not blocked.  <a href="#ga1c582f9a04b1d3332295d9d2ea7bf5b6">More...</a><br /></td></tr>
<tr class="separator:ga1c582f9a04b1d3332295d9d2ea7bf5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064442ec80b455aac7f42e509a28ea87"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga064442ec80b455aac7f42e509a28ea87">rt_receivex_until</a> (RT_TASK *task, void *msg, int size, long *len, RTIME time)</td></tr>
<tr class="memdesc:ga064442ec80b455aac7f42e509a28ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an extended message with an absolute timeout.  <a href="#ga064442ec80b455aac7f42e509a28ea87">More...</a><br /></td></tr>
<tr class="separator:ga064442ec80b455aac7f42e509a28ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6708683452ef412478f68303e1aebe"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed</a> (RT_TASK *task, void *msg, int size, long *len, RTIME delay)</td></tr>
<tr class="memdesc:ga7d6708683452ef412478f68303e1aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an extended message with a relative timeout.  <a href="#ga7d6708683452ef412478f68303e1aebe">More...</a><br /></td></tr>
<tr class="separator:ga7d6708683452ef412478f68303e1aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7ae46a3a1a13048f75a77ce6dc0c3694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_evdrp </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eavedrop (spy) the content of a message. </p>
<p><a class="anchor" id="rt_evdrp"></a>rt_evdrp spies the content of a message from the task specified by <em>task</em> while leaving it on the queue. To actually receive the message any of the rt_receive function must be used specifically. If task is equal to 0, the caller eavdrops the first message of its receive queue, if any. rt_evdrp never blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to any 4 bytes word buffer provided by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if no message is available. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>Referenced by <a class="el" href="group__msg.html#ga81288491d5c7da929767622eba807ae7">rt_evdrpx()</a>, and <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga81288491d5c7da929767622eba807ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_evdrpx </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eavedrop (spy) the content of an extended message. </p>
<p><a class="anchor" id="rt_evdrpx"></a>rt_evdrpx spies the content of a message from the task specified by <em>task</em> while leaving it on the queue. To actually receive the message any of the rt_receivex function must be used specifically. If task is equal to 0, the caller eavdrops the first message of its receive queue, if any. rt_evdrpix never blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td class="paramname">len</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if no message is available. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__msg.html#ga7ae46a3a1a13048f75a77ce6dc0c3694">rt_evdrp()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gafb2e8aa05f0f3b11c3e28924bf63e530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receive </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message. </p>
<p><a class="anchor" id="rt_receive"></a>rt_receive gets a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to any 4 bytes word buffer provided by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br />
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__rpc.html#ga473cb125cabcddda18d4776421e11bc0">rt_return()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga3b744298e1d4565b14f8572490820b14">rt_receivex()</a>, and <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2733ad5fb78c18383f08603f57e65b5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receive_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message, only if the calling task is not blocked. </p>
<p><a class="anchor" id="rt_receive_if"></a>rt_receive_if tries to get a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. The caller task is never blocked but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to a buffer provided by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </p>

<p>References <a class="el" href="group__rpc.html#ga473cb125cabcddda18d4776421e11bc0">rt_return()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga1c582f9a04b1d3332295d9d2ea7bf5b6">rt_receivex_if()</a>, and <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gacffc119c4207193b778ecdfbe62b691d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receive_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message with a relative timeout. </p>
<p><a class="anchor" id="rt_receive_timed"></a>rt_receive_timed receives a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced. In this case these functions return if: a sender sends a message and has a lower priority; any rpced message is received;</p><ul>
<li>timeout occurs;</li>
<li>an error occurs (e.g. the sender task is killed.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td class="paramname">delay</td><td>is a timeout relative to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the sender task is returned. On other failure, a special value is returned. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive.</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
<p>See also: <a class="el" href="group__msg.html#ga152b1feae638de4c1de0beb37f5ff2ca">rt_receive_until()</a>. </p>

<p>References <a class="el" href="group__msg.html#ga152b1feae638de4c1de0beb37f5ff2ca">rt_receive_until()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga152b1feae638de4c1de0beb37f5ff2ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receive_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message with an absolute timeout. </p>
<p><a class="anchor" id="rt_receive_until"></a>rt_receive_until receives a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced. In this case these functions return if: a sender sends a message and has a lower priority; any rpced message is received;</p><ul>
<li>timeout occurs;</li>
<li>an error occurs (e.g. the sender task is killed.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute timout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the sender task is returned. On other failure, a special value is returned. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive.</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
<p>See also: <a class="el" href="group__msg.html#gacffc119c4207193b778ecdfbe62b691d">rt_receive_timed()</a>. </p>

<p>References <a class="el" href="group__rpc.html#ga473cb125cabcddda18d4776421e11bc0">rt_return()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#gacffc119c4207193b778ecdfbe62b691d">rt_receive_timed()</a>, <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>, and <a class="el" href="group__msg.html#ga064442ec80b455aac7f42e509a28ea87">rt_receivex_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b744298e1d4565b14f8572490820b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receivex </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive an extended message. </p>
<p><a class="anchor" id="rt_receivex"></a>rt_receivex gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td class="paramname">len</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br />
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__msg.html#gafb2e8aa05f0f3b11c3e28924bf63e530">rt_receive()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c582f9a04b1d3332295d9d2ea7bf5b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receivex_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive an extended message, only if the calling task is not blocked. </p>
<p><a class="anchor" id="rt_receivex_if"></a>rt_receivex gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. The caller task is never blocked but can be preempted if the task that rt_sentx the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td class="paramname">len</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br />
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__msg.html#ga2733ad5fb78c18383f08603f57e65b5e">rt_receive_if()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d6708683452ef412478f68303e1aebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receivex_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive an extended message with a relative timeout. </p>
<p><a class="anchor" id="rt_receivex_timed"></a>rt_receivex_until gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.</p>
<p>In this case these functions return if: a sender sendxs a message and has a lower priority; any rpcxed message is received;</p><ul>
<li>timeout occurs;</li>
<li>an error occurs (e.g. the sender task is killed.) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td class="paramname">len</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
    <tr><td class="paramname">delay</td><td>is a timeout relative to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br />
 A special value is returned on other failure. The errors are described below:</dd></dl>
</li>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__msg.html#ga7ae46a3a1a13048f75a77ce6dc0c3694">rt_evdrp()</a>, <a class="el" href="group__msg.html#ga81288491d5c7da929767622eba807ae7">rt_evdrpx()</a>, <a class="el" href="group__lxrt.html#gad0556c1daeaeee84c1d73c25cea20b3e">rt_get_adr()</a>, <a class="el" href="group__rpc.html#ga762f7f28bf2d6db5959aa99c6d2c026d">rt_isrpc()</a>, <a class="el" href="group__msg.html#gafb2e8aa05f0f3b11c3e28924bf63e530">rt_receive()</a>, <a class="el" href="group__msg.html#ga2733ad5fb78c18383f08603f57e65b5e">rt_receive_if()</a>, <a class="el" href="group__msg.html#gacffc119c4207193b778ecdfbe62b691d">rt_receive_timed()</a>, <a class="el" href="group__msg.html#ga152b1feae638de4c1de0beb37f5ff2ca">rt_receive_until()</a>, <a class="el" href="group__msg.html#ga3b744298e1d4565b14f8572490820b14">rt_receivex()</a>, <a class="el" href="group__msg.html#ga1c582f9a04b1d3332295d9d2ea7bf5b6">rt_receivex_if()</a>, <a class="el" href="group__msg.html#ga064442ec80b455aac7f42e509a28ea87">rt_receivex_until()</a>, <a class="el" href="group__rpc.html#ga473cb125cabcddda18d4776421e11bc0">rt_return()</a>, <a class="el" href="group__rpc.html#ga8d37f228b699dfba9edec623abd16f1a">rt_returnx()</a>, <a class="el" href="group__rpc.html#ga17ad7344f853873c013928ea1f36e1c2">rt_rpc()</a>, <a class="el" href="group__rpc.html#gaa233167cdde29014c3a42205973b27b3">rt_rpc_if()</a>, <a class="el" href="group__rpc.html#gac5ea4ebf8ed3245ef3c0e78c8ff3a066">rt_rpc_timed()</a>, <a class="el" href="group__rpc.html#ga1939887318d0262c61d132239251921b">rt_rpc_until()</a>, <a class="el" href="group__rpc.html#gad7e2edc4b3007e5e60ae38e570773186">rt_rpcx()</a>, <a class="el" href="group__rpc.html#ga36dee0c8106d27cb4f9fb399be612158">rt_rpcx_if()</a>, <a class="el" href="group__rpc.html#ga783836ff41299a74e78f6a5a02b6b955">rt_rpcx_timed()</a>, <a class="el" href="group__rpc.html#gaa3077fc2e017230f9fe6887d91913767">rt_rpcx_until()</a>, <a class="el" href="group__msg.html#ga66551d6fbb13667461bc3bf2cf83e107">rt_send()</a>, <a class="el" href="group__msg.html#ga70eb31e5f122413970a84758dceb4f90">rt_send_if()</a>, <a class="el" href="group__msg.html#ga5d44740570af52c6a94485e38f6dc9fd">rt_send_timed()</a>, <a class="el" href="group__msg.html#ga27326d8228e55c84003b12585bc10ada">rt_send_until()</a>, <a class="el" href="group__msg.html#ga3b06c847361f918a41815d46786a54c4">rt_sendx()</a>, <a class="el" href="group__msg.html#gaf7d2092690b522efd2a855beded37b7c">rt_sendx_if()</a>, <a class="el" href="group__msg.html#ga9b688e75d34a3b39aca5abdb61e4c900">rt_sendx_timed()</a>, <a class="el" href="group__msg.html#ga7dc1485992f6ae3911b84d4a95403fee">rt_sendx_until()</a>, <a class="el" href="group__lxrt.html#gabe058eed546af153dfb3dea9653a48de">rt_task_init()</a>, <a class="el" href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">rt_task_resume()</a>, and <a class="el" href="api_8c.html#abcabe38a44048bad12d7173a53bc0895">rt_task_suspend()</a>.</p>

</div>
</div>
<a class="anchor" id="ga064442ec80b455aac7f42e509a28ea87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_receivex_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive an extended message with an absolute timeout. </p>
<p><a class="anchor" id="rt_receivex_until"></a>rt_receivex_until gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.</p>
<p>In this case these functions return if: a sender sendxs a message and has a lower priority; any rpcxed message is received;</p><ul>
<li>timeout occurs;</li>
<li>an error occurs (e.g. the sender task is killed.) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td class="paramname">len</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute timout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the sender task is returned upon success.<br />
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br />
 A special value is returned on other failure. The errors are described below:</dd></dl>
</li>
<li><b>0</b>: the sender task was killed before sending the message;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p>References <a class="el" href="group__msg.html#ga152b1feae638de4c1de0beb37f5ff2ca">rt_receive_until()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66551d6fbb13667461bc3bf2cf83e107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_send </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message. </p>
<p><a class="anchor" id="rt_send"></a>rt_send sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message rt_send does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>corresponds to the message that has to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the task that received the message is returned.<br />
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br />
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70eb31e5f122413970a84758dceb4f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_send_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message, only if the calling task will not be blocked. </p>
<p><a class="anchor" id="rt_send_if"></a>rt_send_if sends the message <em>msg</em> to the task <em>task</em> if the latter is ready to receive, so that the caller task is never blocked, but its execution can be preempted if the receiving task is ready to receive and has a higher priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>corresponds to the message that has to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the task <em>task</em> that received the message is returned upon success.<br />
 <em>0</em> is returned if the message has not been sent.<br />
 A special value <em>0xFFFF</em> is returned upon failure.<br />
<br />
 The errors are described below:<ul>
<li><b>0</b>: the task <em>task</em> was not ready to receive the message.</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. (FIXME) </dd></dl>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d44740570af52c6a94485e38f6dc9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_send_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="rt_send_timed"></a>brief Send a message with a relative timeout.</p>
<p>rt_send_timed sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message, this function does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:</p><ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the receiver task is killed).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>corresponds to the message that has to be sent.</td></tr>
    <tr><td class="paramname">delay</td><td>is the timeout relative to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success, the pointer to the task that received the message i.e. the message received before timeout expiration.<br />
 0 if the message has not been sent.<br />
 A special value on other failure. The errors are described below:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: <a class="el" href="group__msg.html#ga27326d8228e55c84003b12585bc10ada">rt_send_until()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. (FIXME) </dd></dl>

<p>References <a class="el" href="group__msg.html#ga27326d8228e55c84003b12585bc10ada">rt_send_until()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27326d8228e55c84003b12585bc10ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_send_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="rt_send_until"></a>brief Send a message with an absolute timeout.</p>
<p>rt_send_until sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message, this function does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:</p><ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the receiver task is killed).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>corresponds to the message that has to be sent.</td></tr>
    <tr><td class="paramname">time</td><td>is the absolute timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the task that received the message is returned on success i.e. the message received before timeout expiration.<br />
 0 is returned if the message has not been sent. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: <a class="el" href="group__msg.html#ga5d44740570af52c6a94485e38f6dc9fd">rt_send_timed()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>, and <a class="el" href="group__msg.html#ga5d44740570af52c6a94485e38f6dc9fd">rt_send_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b06c847361f918a41815d46786a54c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_sendx </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an extended message. </p>
<p><a class="anchor" id="rt_sendx"></a>rt_sendx sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the task that received the message is returned.<br />
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br />
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>References <a class="el" href="group__rpc.html#ga17ad7344f853873c013928ea1f36e1c2">rt_rpc()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7d2092690b522efd2a855beded37b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_sendx_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an extended message, only if the calling task will not be blocked. </p>
<p><a class="anchor" id="rt_sendx_if"></a>rt_sendx_if sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em> if the latter is ready to receive. So the caller task in never blocked but its execution can be preempted if the receiving task has a higher priority.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the task that received the message is returned.<br />
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br />
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b688e75d34a3b39aca5abdb61e4c900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_sendx_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an extended message with relative timeout. </p>
<p><a class="anchor" id="rt_sendx_timed"></a>rt_sendx_until sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx_until does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:</p><ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the receiver task is killed).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">delay</td><td>is r timeout elative to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the task that received the message is returned.<br />
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br />
 A special value is returned as described below in case of a failure:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>References <a class="el" href="group__rpc.html#gac5ea4ebf8ed3245ef3c0e78c8ff3a066">rt_rpc_timed()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7dc1485992f6ae3911b84d4a95403fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK* rt_sendx_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an extended message with absolute timeout. </p>
<p><a class="anchor" id="rt_sendx_until"></a>rt_sendx_until sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx_until does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:</p><ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the receiver task is killed).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to a task structure.</td></tr>
    <tr><td class="paramname">msg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">size</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the task that received the message is returned.<br />
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br />
 A special value is returned as described below in case of a failure:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p>References <a class="el" href="group__rpc.html#ga1939887318d0262c61d132239251921b">rt_rpc_until()</a>.</p>

<p>Referenced by <a class="el" href="group__msg.html#ga7d6708683452ef412478f68303e1aebe">rt_receivex_timed()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
