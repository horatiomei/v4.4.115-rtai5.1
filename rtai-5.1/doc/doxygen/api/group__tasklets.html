<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RTAI API: module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTAI API
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tasklets.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">module</div>  </div>
</div><!--header-->
<div class="contents">

<p>The tasklets module adds an interesting feature along the line, pioneered by RTAI, of a symmetric usage of all its services inter-intra kernel and user space, both for soft and hard real time applications.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rtai__nam2num_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>
<tr class="memdesc:rtai__nam2num_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion between 6 characters strings and unsigned long identifiers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__tasklets_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__tasklets_8h.html">rtai_tasklets.h</a></td></tr>
<tr class="memdesc:rtai__tasklets_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the <a class="el" href="group__tasklets.html">mini LXRT RTAI tasklets module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tasklets_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tasklets_8c.html">tasklets.c</a></td></tr>
<tr class="memdesc:tasklets_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="group__tasklets.html">RTAI tasklets module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga67b50b50295add10457e86b00b855367"><td class="memItemLeft" align="right" valign="top">static struct rt_usp_tasklet_struct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet</a> (void)</td></tr>
<tr class="memdesc:ga67b50b50295add10457e86b00b855367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init, in kernel space, a tasklet structure to be used in user space.  <a href="#ga67b50b50295add10457e86b00b855367">More...</a><br /></td></tr>
<tr class="separator:ga67b50b50295add10457e86b00b855367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2270c8d5f50943607405a5ac750f3822"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga2270c8d5f50943607405a5ac750f3822">rt_insert_tasklet</a> (struct rt_tasklet_struct *tasklet, int priority, void(*handler)(unsigned long), unsigned long data, unsigned long id, int pid)</td></tr>
<tr class="memdesc:ga2270c8d5f50943607405a5ac750f3822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a tasklet in the list of tasklets to be processed.  <a href="#ga2270c8d5f50943607405a5ac750f3822">More...</a><br /></td></tr>
<tr class="separator:ga2270c8d5f50943607405a5ac750f3822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65af2e314eabb55a94c9cfb016afa347"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga65af2e314eabb55a94c9cfb016afa347">rt_remove_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>
<tr class="memdesc:ga65af2e314eabb55a94c9cfb016afa347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a tasklet in the list of tasklets to be processed.  <a href="#ga65af2e314eabb55a94c9cfb016afa347">More...</a><br /></td></tr>
<tr class="separator:ga65af2e314eabb55a94c9cfb016afa347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9f6b4f937a3eecc9a6b4b9a953a84a"><td class="memItemLeft" align="right" valign="top">struct rt_tasklet_struct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#gadc9f6b4f937a3eecc9a6b4b9a953a84a">rt_find_tasklet_by_id</a> (unsigned long id)</td></tr>
<tr class="memdesc:gadc9f6b4f937a3eecc9a6b4b9a953a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a tasklet identified by its id.  <a href="#gadc9f6b4f937a3eecc9a6b4b9a953a84a">More...</a><br /></td></tr>
<tr class="separator:gadc9f6b4f937a3eecc9a6b4b9a953a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b785329803fd9715003f3a6f893f426"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga0b785329803fd9715003f3a6f893f426">rt_exec_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>
<tr class="memdesc:ga0b785329803fd9715003f3a6f893f426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exec a tasklet.  <a href="#ga0b785329803fd9715003f3a6f893f426">More...</a><br /></td></tr>
<tr class="separator:ga0b785329803fd9715003f3a6f893f426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b54d42addaa7a0498366aeceecadaca"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga6b54d42addaa7a0498366aeceecadaca">rt_insert_timer</a> (struct rt_tasklet_struct *timer, int priority, RTIME firing_time, RTIME period, void(*handler)(unsigned long), unsigned long data, int pid)</td></tr>
<tr class="memdesc:ga6b54d42addaa7a0498366aeceecadaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a timer in the list of timers to be processed.  <a href="#ga6b54d42addaa7a0498366aeceecadaca">More...</a><br /></td></tr>
<tr class="separator:ga6b54d42addaa7a0498366aeceecadaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216fa74c7baf1cd6e5169244aabf2c91"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga216fa74c7baf1cd6e5169244aabf2c91">rt_remove_timer</a> (struct rt_tasklet_struct *timer)</td></tr>
<tr class="memdesc:ga216fa74c7baf1cd6e5169244aabf2c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a timer in the list of timers to be processed.  <a href="#ga216fa74c7baf1cd6e5169244aabf2c91">More...</a><br /></td></tr>
<tr class="separator:ga216fa74c7baf1cd6e5169244aabf2c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc0b1d764680a90335d6e848f08ce69"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga8cc0b1d764680a90335d6e848f08ce69">rt_set_timer_priority</a> (struct rt_tasklet_struct *timer, int priority)</td></tr>
<tr class="memdesc:ga8cc0b1d764680a90335d6e848f08ce69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the priority of an existing timer.  <a href="#ga8cc0b1d764680a90335d6e848f08ce69">More...</a><br /></td></tr>
<tr class="separator:ga8cc0b1d764680a90335d6e848f08ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8419d937336c3ee8e23ece7b01213ea4"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga8419d937336c3ee8e23ece7b01213ea4">rt_set_timer_firing_time</a> (struct rt_tasklet_struct *timer, RTIME firing_time)</td></tr>
<tr class="memdesc:ga8419d937336c3ee8e23ece7b01213ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the firing time of a timer.  <a href="#ga8419d937336c3ee8e23ece7b01213ea4">More...</a><br /></td></tr>
<tr class="separator:ga8419d937336c3ee8e23ece7b01213ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4d71d306a4049b80027a8020256122c"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#gaf4d71d306a4049b80027a8020256122c">rt_set_timer_period</a> (struct rt_tasklet_struct *timer, RTIME period)</td></tr>
<tr class="memdesc:gaf4d71d306a4049b80027a8020256122c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the period of a timer.  <a href="#gaf4d71d306a4049b80027a8020256122c">More...</a><br /></td></tr>
<tr class="separator:gaf4d71d306a4049b80027a8020256122c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>
<tr class="memdesc:ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete, in kernel space, a tasklet structure to be used in user space.  <a href="#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">More...</a><br /></td></tr>
<tr class="separator:ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The tasklets module adds an interesting feature along the line, pioneered by RTAI, of a symmetric usage of all its services inter-intra kernel and user space, both for soft and hard real time applications. </p>
<p>In such a way you have opened a whole spectrum of development and implementation lanes, allowing maximum flexibility with uncompromized performances.</p>
<p>The new services provided can be useful when you have many tasks, both in kernel and user space, that must execute simple, often ripetitive, functions, both in soft and hard real time, asynchronously within their parent application. Such tasks are here called tasklets and can be of two kinds: normal tasklets and timed tasklets (timers).</p>
<p>It must be noted that only timers should need to be made available both in user and kernel space. In fact normal tasklets in kernel space are nothing but standard functions that can be directly executed by calling them, so there would be no need for any special treatment. However to maintain full usage symmetry and to ease any possible porting from one address space to the other, plain tasklets can be used in the same way from whatever address space.</p>
<p>Tasklets should be used where and whenever the standard hard real time RTAI tasks are used. Instances of such applications are timed polling and simple Programmable Logic Controllers (PLC) like sequences of services. Obviously there are many others instances that can make it sufficient the use of tasklets, either normal or timers. In general such an approach can be a very useful complement to fully featured tasks in controlling complex machines and systems, both for basic and support services.</p>
<p>It is remarked that the implementation found here for timed tasklets rely on server support tasks, one per cpu, that execute the related timer functions, either in oneshot or periodic mode, on the base of their time deadline and according to their, user assigned, priority. Instead, as told above, plain tasklets are just functions executed from kernel space; their execution needs no server and is simply triggered by calling a given service function at due time, either from a kernel task or interrupt handler requiring, or in charge of, their execution whenever they are needed.</p>
<p>Note that in user space you run within the memory of the process owning the tasklet function so you MUST lock all of your tasks memory in core, by using mlockall, to prevent it being swapped out. Pre grow also your stack to the largest size needed during the execution of your application, see mlockall usage in Linux mans.</p>
<p>The RTAI distribution contains many useful examples that demonstrate the use of most tasklets services, both in kernel and user space. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_delete_tasklet </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>tasklet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete, in kernel space, a tasklet structure to be used in user space. </p>
<p>rt_tasklet_delete free a tasklet structure (struct rt_tasklet_struct) in kernel space that was allocated by rt_tasklet_init.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasklet</td><td>is the pointer to the tasklet structure (struct rt_tasklet_struct) returned by rt_tasklet_init.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is to be used only for user space tasklets. In kernel space it is just an empty macro, as the user can, and must allocate the related structure directly, either statically or dynamically. </p>

<p>References <a class="el" href="group__tasklets.html#ga0b785329803fd9715003f3a6f893f426">rt_exec_tasklet()</a>, <a class="el" href="group__tasklets.html#gadc9f6b4f937a3eecc9a6b4b9a953a84a">rt_find_tasklet_by_id()</a>, <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>, <a class="el" href="group__tasklets.html#ga2270c8d5f50943607405a5ac750f3822">rt_insert_tasklet()</a>, <a class="el" href="group__tasklets.html#ga6b54d42addaa7a0498366aeceecadaca">rt_insert_timer()</a>, <a class="el" href="group__tasklets.html#ga65af2e314eabb55a94c9cfb016afa347">rt_remove_tasklet()</a>, <a class="el" href="group__tasklets.html#ga216fa74c7baf1cd6e5169244aabf2c91">rt_remove_timer()</a>, <a class="el" href="group__tasklets.html#ga8419d937336c3ee8e23ece7b01213ea4">rt_set_timer_firing_time()</a>, <a class="el" href="group__tasklets.html#gaf4d71d306a4049b80027a8020256122c">rt_set_timer_period()</a>, <a class="el" href="group__tasklets.html#ga8cc0b1d764680a90335d6e848f08ce69">rt_set_timer_priority()</a>, and <a class="el" href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">rt_task_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b785329803fd9715003f3a6f893f426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_exec_tasklet </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>tasklet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exec a tasklet. </p>
<p>rt_exec_tasklet execute a tasklet from the list of tasklets to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasklet</td><td>is the pointer to the tasklet structure to be used to manage the tasklet <em>tasklet</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Kernel space tasklets addresses are usually available directly and can be easily be used in calling rt_tasklet_exec. In fact one can call the related handler directly without using such a support function, which is mainly supplied for symmetry and to ease the porting of applications from one space to the other.</p>
<p>User space tasklets instead must be first found within the tasklet list by calling <a class="el" href="group__tasklets.html#gadc9f6b4f937a3eecc9a6b4b9a953a84a" title="Find a tasklet identified by its id. ">rt_find_tasklet_by_id()</a> to get the tasklet address to be used in rt_tasklet_exec(). </p>

<p>References <a class="el" href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">rt_task_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="gadc9f6b4f937a3eecc9a6b4b9a953a84a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rt_tasklet_struct* rt_find_tasklet_by_id </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a tasklet identified by its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the unique unsigned long to be used to identify the tasklet.</td></tr>
  </table>
  </dd>
</dl>
<p>The support functions nam2num() and num2nam() can be used for setting up id from a six character string.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to a tasklet handler on success </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>to indicate that <em>id</em> is not a valid identifier so that the related tasklet was not found. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga67b50b50295add10457e86b00b855367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct rt_tasklet_struct * rt_init_tasklet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Init, in kernel space, a tasklet structure to be used in user space. </p>
<p>rt_tasklet_init allocate a tasklet structure (struct rt_tasklet_struct) in kernel space to be used for the management of a user space tasklet.</p>
<p>This function is to be used only for user space tasklets. In kernel space it is just an empty macro, as the user can, and must allocate the related structure directly, either statically or dynamically.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the tasklet structure the user space application must use to access all its related services. </dd></dl>

<p>References <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, <a class="el" href="group__tasklets.html#ga0b785329803fd9715003f3a6f893f426">rt_exec_tasklet()</a>, <a class="el" href="group__tasklets.html#ga2270c8d5f50943607405a5ac750f3822">rt_insert_tasklet()</a>, <a class="el" href="group__tasklets.html#ga6b54d42addaa7a0498366aeceecadaca">rt_insert_timer()</a>, <a class="el" href="group__lxrt.html#gaad31bb1f13d9b46f704f0c3483db92cd">rt_make_hard_real_time()</a>, <a class="el" href="group__lxrt.html#gac55eb260c78e84d57699afc9e16a80fd">rt_make_soft_real_time()</a>, <a class="el" href="group__tasklets.html#ga65af2e314eabb55a94c9cfb016afa347">rt_remove_tasklet()</a>, <a class="el" href="group__tasklets.html#ga216fa74c7baf1cd6e5169244aabf2c91">rt_remove_timer()</a>, <a class="el" href="group__tasklets.html#ga8419d937336c3ee8e23ece7b01213ea4">rt_set_timer_firing_time()</a>, <a class="el" href="group__tasklets.html#gaf4d71d306a4049b80027a8020256122c">rt_set_timer_period()</a>, <a class="el" href="group__tasklets.html#ga8cc0b1d764680a90335d6e848f08ce69">rt_set_timer_priority()</a>, and <a class="el" href="api_8c.html#abc70267c2a16cfe8f1de3763ae2d438f">rt_task_use_fpu()</a>.</p>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#gaf4d71d306a4049b80027a8020256122c">rt_set_timer_period()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2270c8d5f50943607405a5ac750f3822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_insert_tasklet </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>tasklet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a tasklet in the list of tasklets to be processed. </p>
<p>rt_insert_tasklet insert a tasklet in the list of tasklets to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasklet</td><td>is the pointer to the tasklet structure to be used to manage the tasklet at hand.</td></tr>
    <tr><td class="paramname">handler</td><td>is the tasklet function to be executed.</td></tr>
    <tr><td class="paramname">data</td><td>is an unsigned long to be passed to the handler. Clearly by an appropriate type casting one can pass a pointer to whatever data structure and type is needed.</td></tr>
    <tr><td class="paramname">id</td><td>is a unique unsigned number to be used to identify the tasklet tasklet. It is typically required by the kernel space service, interrupt handler ot task, in charge of executing a user space tasklet. The support functions nam2num() and num2nam() can be used for setting up id from a six character string.</td></tr>
    <tr><td class="paramname">pid</td><td>is an integer that marks a tasklet either as being a kernel or user space one. Despite its name you need not to know the pid of the tasklet parent process in user space. Simple use 0 for kernel space and 1 for user space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a negative number to indicate that an invalid handler address has been passed. </dd></dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b54d42addaa7a0498366aeceecadaca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_insert_timer </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>firing_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(unsigned long)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a timer in the list of timers to be processed. </p>
<p>rt_insert_timer insert a timer in the list of timers to be processed. Timers can be either periodic or oneshot. A periodic timer is reloaded at each expiration so that it executes with the assigned periodicity. A oneshot timer is fired just once and then removed from the timers list. Timers can be reinserted or modified within their handlers functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td class="paramname">priority</td><td>is the priority to be used to execute timers handlers when more than one timer has to be fired at the same time.It can be assigned any value such that: 0 &lt; priority &lt; RT_LOWEST_PRIORITY.</td></tr>
    <tr><td class="paramname">firing_time</td><td>is the time of the first timer expiration.</td></tr>
    <tr><td class="paramname">period</td><td>is the period of a periodic timer. A periodic timer keeps calling its handler at firing_time + k*period k = 0, 1. To define a oneshot timer simply use a null period.</td></tr>
    <tr><td class="paramname">handler</td><td>is the timer function to be executed at each timer expiration.</td></tr>
    <tr><td class="paramname">data</td><td>is an unsigned long to be passed to the handler. Clearly by a appropriate type casting one can pass a pointer to whatever data structure and type is needed.</td></tr>
    <tr><td class="paramname">pid</td><td>is an integer that marks a timer either as being a kernel or user space one. Despite its name you need not to know the pid of the timer parent process in user space. Simple use 0 for kernel space and 1 for user space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>handler</em> is an invalid handler address </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga65af2e314eabb55a94c9cfb016afa347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_remove_tasklet </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>tasklet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a tasklet in the list of tasklets to be processed. </p>
<p>rt_remove_tasklet remove a tasklet from the list of tasklets to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasklet</td><td>is the pointer to the tasklet structure to be used to manage the tasklet at hand. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga216fa74c7baf1cd6e5169244aabf2c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_remove_timer </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a timer in the list of timers to be processed. </p>
<p>rt_remove_timer remove a timer from the list of the timers to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the pointer to the timer structure to be used to manage the timer at hand. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8419d937336c3ee8e23ece7b01213ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_set_timer_firing_time </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>firing_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the firing time of a timer. </p>
<p>rt_set_timer_firing_time changes the firing time of a periodic timer overloading any existing value, so that the timer next shoot will take place at the new firing time. Note that if a oneshot timer has its firing time changed after it has already expired this function has no effect. You should reinsert it in the timer list with the new firing time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td class="paramname">firing_time</td><td>is the new time of the first timer expiration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used within the timer handler.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4d71d306a4049b80027a8020256122c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_set_timer_period </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the period of a timer. </p>
<p>rt_set_timer_period changes the period of a periodic timer. Note that the new period will be used to pace the timer only after the expiration of the firing time already in place. Using this function with a period different from zero for a oneshot timer, that has not expired yet, will transform it into a periodic timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td class="paramname">period</td><td>is the new period of a periodic timer.</td></tr>
  </table>
  </dd>
</dl>
<p>The macro #rt_fast_set_timer_period can substitute the corresponding function in kernel space if both the existing timer period and the new one fit into an 32 bits integer.</p>
<p>This function an be used within the timer handler.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>, <a class="el" href="api_8c.html#a2217e92524304d5eccc037cda6a37a74">rt_sleep_until()</a>, and <a class="el" href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">rt_task_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8cc0b1d764680a90335d6e848f08ce69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_set_timer_priority </td>
          <td>(</td>
          <td class="paramtype">struct rt_tasklet_struct *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the priority of an existing timer. </p>
<p>rt_set_timer_priority change the priority of an existing timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td class="paramname">priority</td><td>is the priority to be used to execute timers handlers when more than one timer has to be fired at the same time. It can be assigned any value such that: 0 &lt; priority &lt; RT_LOWEST_PRIORITY.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used within the timer handler. </p>

<p>Referenced by <a class="el" href="group__tasklets.html#ga70c6f1a8ef5a0c3c59c2a72be6fd7f1f">rt_delete_tasklet()</a>, and <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
